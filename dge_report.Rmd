---
title: "Expressão Diferencial"
author: "João Vitor F. Cavalcante"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme:
      bslib: true
      bootswatch: minty
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  eval = FALSE
)
```

# Breve descrição da metodologia

* Expressão diferencial de MicroArrays
  - Foi utilizado para obter as matrizes de contagem normalizadas, os pacotes do Bioconductor:
    - **affy** (GSE59672 e GSE30110)
    - **oligo** (GSE64476)
    - **limma** (GSE40289 e GSE15449)
  - Para realizar a expressão diferencial em si, utilizamos:
    - **limma** (Genes D.E. definidos para p-valor < 0.01 e método BH para ajuste de p-valor)

* Expressão diferencial de RNA-Seq (GSE154603)
  - Primeiro, obtemos as reads pelo SRA (SRP272292)
  - Para criação do índice, utilizamos o transcriptoma de Rattus norvegicus mRatBN7.2, da versão 106 do banco de dados Ensembl
  - Em seguida, alinhamos com o **Kallisto** versão 0.48.0
  - Lemos as contagens obtidas do Kallisto com o pacote **tximport**, que agregou as contagens em nível de transcrito para nível de gene
  - Por fim, realizamos a expressão diferencial com o pacote **DESeq2**, com os parâmetros predefinidos

# Expressão diferencial de MicroArrays

## Carregando bibliotecas e funções

```{r bibs1, echo=FALSE}
library(affy)
library(oligo)
library(limma)
library(readr)
library(dplyr)
library(mouse4302.db)
library(porcine.db)
```

```{r array-funcs}

# Carregar tabela com metadados do estudo de interesse
get_phenodata <- function(gse_id) {
  read_csv("data/Coleta dos GSE - Daniel Sturza - GEO.csv") %>%
    janitor::clean_names() %>%
    filter(gse == gse_id) %>%
    dplyr::select(gsm, grupo, grupo_no_trabalho_original)
}

# Rodar a expressão diferencial com limma
get_limma_dexp <-
  function(eset,
           phenodata,
           contraste,
           symbol = NULL,
           add_id = NULL,
           platform_df = NULL) {
    eset_df <- exprs(eset)

    design <- model.matrix(~ 0 + factor(phenodata$grupo))
    colnames(design) <- unique(phenodata$grupo)

    fit <- limma::lmFit(eset, design)

    if (is.null(platform_df)) {
      db_symbol <- as.data.frame(symbol[rownames(eset_df)])

      db_add_id <- as.data.frame(add_id[rownames(eset_df)])

      platform_df <-
        db_add_id %>% left_join(db_symbol, by = "probe_id")
    }

    contrasts <-
      limma::makeContrasts(contrasts = contraste, levels = design)

    fit2 <- contrasts.fit(fit, contrasts)

    ct.fit <- limma::eBayes(fit2)

    res.fit <-
      limma::decideTests(
        ct.fit,
        method = "global",
        adjust.method = "BH",
        p.value = 0.01,
      )

    is_de = as.data.frame(res.fit@.Data) %>%
      tibble::rownames_to_column("probe") %>%
      setNames(., c("probe", "is_de"))

    topTable(
      ct.fit,
      coef = 1,
      adjust.method = "BH",
      number = "inf",
      confint = TRUE
    ) %>%
      tibble::rownames_to_column("probe") %>%
      left_join(is_de, by = "probe") %>%
      left_join(platform_df, by = c("probe" = "probe_id"))

  }

# Retirar duplicatas
clean_toptable <- function(toptable, unique_col) {
  ref_col = dplyr::sym(unique_col)
  toptable %>%
    group_by(!!ref_col) %>%
    slice(which.max(abs(logFC))) %>%
    ungroup()
}

# Função principal que agrega as acima
# Carrega o dado com a tecnologia apropriada (affymetrix, affy-oligo ou agilent)
# Roda a expressão diferencial e retorna a tabela
get_dge_table <-
  function(gse_id,
           celfile_path,
           contraste,
           symbol = NULL,
           add_id = NULL,
           refcol =  "symbol",
           platform_df = NULL,
           oligo_exp = FALSE,
           agilent = FALSE) {
    phenodata_file <- get_phenodata(gse_id)

    if (oligo_exp == TRUE) {
      celfiles <-
        list.files(celfile_path, pattern = "CEL.gz", full.names = TRUE)
      data <-
        oligo::read.celfiles(celfile.path = celfiles)
      eset <- oligo::rma(data)
    } else if (agilent == TRUE) {
      celfiles <- list.files(celfile_path, pattern = "txt.gz")
      raw <-
        read.maimages(celfiles,
                      path = celfile_path,
                      source = "agilent",
                      green.only = TRUE)
      norm <- backgroundCorrect(raw, method = "normexp")
      norm <- normalizeBetweenArrays(norm, method = "quantile")
      norm.ave <- avereps(norm, ID = norm$genes$ProbeName)

      eset <- Biobase::ExpressionSet(assayData = norm.ave$E)
    } else {
      data <-
        affy::ReadAffy(celfile.path = celfile_path)

      eset <- affy::rma(data)
    }


    toptable <- get_limma_dexp(
      eset,
      phenodata_file,
      contraste,
      symbol = symbol,
      add_id = add_id,
      platform_df = platform_df
    )

    clean_toptable(toptable, unique_col = refcol)

  }
```

## Expressão diferencial para cada estudo

Primeiro vamos carregar os dados relativos às plataformas que não possuem bancos de dados cadastrados no BioConductor, que é a maioria. Esse dado, adquirido da página de cada plataforma no GEO, será utilizado para obter o gene symbol relativo às sondas no resultado final.

```{r platforms}
GPL6246 <- read_csv("data/GPL6246.csv") %>%
  mutate(probe_id = as.character(probe_id)) %>%
  janitor::clean_names() %>%
  dplyr::select(probe_id, gene_symbol, gene_id) %>%
  tidyr::separate_rows(gene_symbol, sep = "///")

GPL13912 <- read_csv("data/GPL13912.csv") %>%
  dplyr::select(probe_id, GENE_SYMBOL, ENSEMBL_ID) %>%
  janitor::clean_names()

GPL7294 <- read_csv("data/GPL7294.csv") %>%
  dplyr::select(probe_id, GENE_SYMBOL, ENSEMBL_ID) %>%
  janitor::clean_names()
```

Agora podemos rodar a expressão diferencial para cada estudo:

```{r marray_dexp}
GSE59672 <-
  get_dge_table(
    "GSE59672",
    "data/DGE/GSE59672",
    "Tratado-Controle",
    symbol = mouse4302SYMBOL,
    add_id = mouse4302ENSEMBL
  )

GSE30110 <-
  get_dge_table(
    "GSE30110",
    "data/DGE/GSE30110",
    "Tratado-Controle",
    symbol = porcineSYMBOL,
    add_id = porcineENTREZID
  )

GSE64476 <-
  get_dge_table(
    "GSE64476",
    "data/DGE/GSE64476",
    "Tratado-Controle",
    platform_df = GPL6246,
    refcol = "gene_symbol",
    oligo_exp = TRUE,

  )

GSE40289 <-
  get_dge_table(
    "GSE40289",
    "data/DGE/GSE40289",
    "Tratado-Controle",
    platform_df = GPL13912,
    refcol = "gene_symbol",
    agilent = TRUE
  )

GSE15449 <-
  get_dge_table(
    "GSE15449",
    "data/DGE/GSE15449",
    "Tratado-Controle",
    platform_df = GPL7294,
    refcol = "gene_symbol",
    agilent = TRUE
  )

```

Agora vamos salvar cada uma das tabelas como um arquivo .csv

```{r write-marray}
marray_results <- list(
  GSE15449 = GSE15449,
  GSE64476 = GSE64476,
  GSE30110 = GSE30110,
  GSE59672 = GSE59672,
  GSE40289 = GSE40289
)

purrr::walk2(marray_results,
             names(marray_results),
             ~ write_csv(.x, paste0("results/dge/", .y, '.csv')))
```

Limpando o ambiente:

```{r}
rm(list = ls(all.names = TRUE))
gc()
```

# Expressão diferencial de RNA-Seq (GSE154603)

Após alinharmos os dados com o Kallisto, colocamos os dados na pasta 'resultados/kallisto_results'.

## Carregando bibliotecas

```{r rnaseq-libs}
library(BiocParallel)
library(tximport)
library(biomaRt)
library(DESeq2)
library(readr)
library(dplyr)
```

## Lendo os metadados do estudo

Primeiro, vamos ler a tabela de metadados do estudo, que pode ser obtida [aqui (botão Metadata)](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=SRP272292&o=acc_s%3Aa)

```{r rnaseq-metadata}
files <-
  list.files(
    "data/kallisto_results",
    pattern =  ".h5",
    full.names = TRUE,
    recursive = TRUE
  )

run_names <- stringr::str_extract_all(files, "SRR\\d+", simplify = TRUE)

metadata <- read_csv("data/GSE154603_metadata.txt") %>%
  janitor::clean_names() %>%
  mutate(grupo = ifelse(group == "saline control", "Controle", "Tratado")) %>%
  arrange(match(run, run_names))

samples <- metadata %>%
  select(run, grupo) %>%
  setNames(c("run", "contrast"))

samples$contrast <- as.factor(samples$contrast)
```

## Lendo contagens

Para ler as tabelas de counts, utilizaremos o tximport, que irá converter o dado de nível de transcrito para nível de gene e converter os identificadores (ENST -> ENSG).

```{r tximport}
gtf <- "data/Rattus_norvegicus.mRatBN7.2.106.gtf.gz"
txdb.filename <- "data/Rattus_norvegicus.mRatBN7.2.106.gtf.sqlite"

if (!("Rattus_norvegicus.mRatBN7.2.106.gtf.sqlite" %in% list.files("data"))) {
  txdb <- GenomicFeatures::makeTxDbFromGFF(gtf, format = "gtf")
  AnnotationDbi::saveDb(txdb, txdb.filename)
}

# Carregar txdb
txdb <- AnnotationDbi::loadDb(txdb.filename)
txdf <-
  AnnotationDbi::select(txdb, keys(txdb, "GENEID"), "TXNAME", "GENEID")
tab <- table(txdf$GENEID)
txdf$ntx <- tab[match(txdf$GENEID, names(tab))]
tx2gene <- data.frame(
  tx = txdf$TXNAME,
  gene = txdf$GENEID,
  stringsAsFactors = F
)

count_matrix <-
  tximport(
    files = files,
    type = "kallisto",
    tx2gene = tx2gene,
    ignoreTxVersion = T
  )
```

## Expressão diferencial

Agora que temos os contrastes, podemos rodar o DESeq2 para realizar a expressão diferencial.

```{r deseq}
rnovergicus_deseqobj <-
  DESeqDataSetFromTximport(count_matrix,
                           colData = samples,
                           design = ~ contrast)

dds <-
  DESeq(rnovergicus_deseqobj,
        parallel = TRUE,
        BPPARAM = MulticoreParam(2))

res <- results(
  dds,
  contrast = c("contrast", "Tratado", "Controle"),
  tidy = TRUE
)

```

Agora vamos adquirir os symbols relativos aos ENSG:

```{r translate-ids}
ensembl <-
  useEnsembl(biomart = "genes", dataset = "rnorvegicus_gene_ensembl")

translated <- getBM(
  attributes = c('ensembl_gene_id',
                 'rgd_symbol'),
  filters = 'ensembl_gene_id',
  values = res$row,
  mart = ensembl
)

res_transl <- res %>%
  left_join(translated, by = c("row" = "ensembl_gene_id")) %>% 
  group_by(rgd_symbol) %>%
  slice(which.min(padj)) %>%
  ungroup()
```

Adicionar os intervalos de confiança (95%) para o resultado do DESeq2:

```{r confint}
res_transl_confint <- res_transl %>%
  mutate(CI.L = log2FoldChange - (qnorm(0.95) * lfcSE),
         CI.R = log2FoldChange + (qnorm(0.95) * lfcSE))

```

E, por fim, escrever o resultado final para uma tabela .csv.

```{r write-rnaseq}
res_transl_confint %>%
  write_csv('results/dge/GSE154603.csv')
```



